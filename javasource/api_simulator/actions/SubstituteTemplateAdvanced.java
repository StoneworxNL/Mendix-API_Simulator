// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package api_simulator.actions;

import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.IMendixObjectMember;
import com.mendix.systemwideinterfaces.core.meta.IMetaEnumValue;
import com.mendix.systemwideinterfaces.core.meta.IMetaEnumeration;
import com.mendix.core.Core;
import com.mendix.core.objectmanagement.member.MendixDateTime;
import com.mendix.core.objectmanagement.member.MendixEnum;
import com.mendix.core.objectmanagement.member.MendixObjectReference;
import com.mendix.core.objectmanagement.member.MendixObjectReferenceSet;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixIdentifier;
import com.mendix.webui.CustomJavaAction;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.function.Function;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Identical to SubstituteTemplate, but adds an datetimeformat argument
 * 
 * DateTimeFormat identifies a format string which is applied to date/time based attributes. Can be left empty. Defaults to "EEE dd MMM yyyy, HH:mm"
 */
public class SubstituteTemplateAdvanced extends CustomJavaAction<java.lang.String>
{
	private java.lang.String template;
	private IMendixObject substitute;
	private java.lang.Boolean useHTMLEncoding;
	private java.lang.String datetimeformat;

	public SubstituteTemplateAdvanced(IContext context, java.lang.String template, IMendixObject substitute, java.lang.Boolean useHTMLEncoding, java.lang.String datetimeformat)
	{
		super(context);
		this.template = template;
		this.substitute = substitute;
		this.useHTMLEncoding = useHTMLEncoding;
		this.datetimeformat = datetimeformat;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
		return substituteTemplate(this.getContext(), template, substitute, useHTMLEncoding, this.datetimeformat);
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "SubstituteTemplateAdvanced";
	}

	// BEGIN EXTRA CODE
	public static String substituteTemplate(final IContext context, String template,
											final IMendixObject substitute, final boolean HTMLEncode, final String datetimeformat) {
		return regexReplaceAll(template, "\\{(@)?(.*?)\\}", (MatchResult match) -> {
			String value;
			String path = match.group(2);
			if (match.group(1) != null) {
				value = String.valueOf(Core.getConfiguration().getConstantValue(path));
			} else {
				try {
					value = getValueOfPath(context, substitute, path, datetimeformat);
				} catch (Exception e) {
					throw new RuntimeException(e);
				}
			}
			return value;
		});
	}

	public static String regexReplaceAll(String source, String regexString, Function<MatchResult, String> replaceFunction) {
		if (source == null || source.trim().isEmpty()) // avoid NPE's, save CPU
		{
			return "";
		}

		StringBuffer resultString = new StringBuffer();
		Pattern regex = Pattern.compile(regexString);
		Matcher regexMatcher = regex.matcher(source);

		while (regexMatcher.find()) {
			MatchResult match = regexMatcher.toMatchResult();
			String value = replaceFunction.apply(match);
			regexMatcher.appendReplacement(resultString, Matcher.quoteReplacement(value));
		}
		regexMatcher.appendTail(resultString);

		return resultString.toString();
	}

	public static String getValueOfPath(IContext context, IMendixObject substitute, String fullpath, String datetimeformat) throws Exception {
		String[] path = fullpath.split("/");
		if (path.length == 1) {
			return getMemberValueAsString(substitute,path[0],context,datetimeformat);			
			
		} else if (path.length == 0) {
			throw new Exception("communitycommons.ORM.getValueOfPath: Unexpected end of path.");
		} else {
			String targetAttribute = path[path.length - 1];
			String targetEntity = path[path.length - 2];
			String pathToRequest = invertPath(fullpath.substring(0, fullpath.lastIndexOf(targetEntity)-1));			
			String xPath = (new StringBuilder()).append("//").append(targetEntity).append("[").append(pathToRequest).append("=").append(substitute.getId().toLong()).append("]").toString();
					
			
			List<IMendixObject> results = Core.createXPathQuery(xPath)
			.setAmount(1)
			.execute(context);
			
			if(results.size() >= 1) {
				IMendixObject targetobj = results.get(0);
				return getMemberValueAsString(targetobj,targetAttribute,context,datetimeformat);	
			}
			else {
				return "";
			}
			
			
			
		}
	}
	
	public static String invertPath (String pathToRequest) {
		String[] segments = pathToRequest.split("/");
		if (segments.length == 1) {
			return pathToRequest;
		}
		else {
			Collections.reverse(Arrays.asList(segments));
		    String result = "";
		    for (String s: segments) {
		    	result = result.concat(s).concat("/");
		    }
		    
		    return result.substring(0, result.length() - 1);	
		}
	    		
	}
	
	public static String getMemberValueAsString(IMendixObject substitute, String memberName, IContext context, String datetimeformat) {
		IMendixObjectMember<?> member = substitute.getMember(context, memberName);

		//special case, see ticket 9135, format datetime.
		if (member instanceof MendixDateTime) {
			Date time = ((MendixDateTime) member).getValue(context);
			if (time == null) {
				return "";
			}
			String f = datetimeformat != null && !datetimeformat.isEmpty() ? datetimeformat : "EEE dd MMM yyyy, HH:mm";
			return new SimpleDateFormat(f).format(time);
		}

		if (member instanceof MendixEnum) {
			String value = member.parseValueToString(context);
			if (value == null || value.isEmpty()) {
				return "";
			}

			IMetaEnumeration enumeration = ((MendixEnum) member).getEnumeration();
			IMetaEnumValue evalue = enumeration.getEnumValues().get(value);
			return Core.getInternationalizedString(context, evalue.getI18NCaptionKey());
		}
		//default
		return member.parseValueToString(context);
	}
	// END EXTRA CODE
}
